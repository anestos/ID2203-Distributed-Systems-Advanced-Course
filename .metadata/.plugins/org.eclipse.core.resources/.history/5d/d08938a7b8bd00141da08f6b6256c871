package se.kth.ict.id2203.components.multipaxos;

import java.util.HashMap;
import java.util.List;
import java.util.Set;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import se.kth.ict.id2203.ports.asc.AbortableSequenceConsensus;
import se.kth.ict.id2203.ports.asc.AscPropose;
import se.kth.ict.id2203.ports.beb.BebBroadcast;
import se.kth.ict.id2203.ports.fpl.FIFOPerfectPointToPointLink;
import se.kth.ict.id2203.ports.fpl.FplSend;
import se.sics.kompics.ComponentDefinition;
import se.sics.kompics.Handler;
import se.sics.kompics.Negative;
import se.sics.kompics.Positive;
import se.sics.kompics.address.Address;

public class MultiPaxos extends ComponentDefinition {

	private static final Logger logger = LoggerFactory.getLogger(MultiPaxos.class);

	private Negative<AbortableSequenceConsensus> asc = provides(AbortableSequenceConsensus.class);
	private Positive<FIFOPerfectPointToPointLink> fpl = requires(FIFOPerfectPointToPointLink.class);

	private int t;
	private int prepts;
	private int ats;
	private List<Object> av;
	private int al;
	private int pts;
	private List<Object> pv;
	private int pl;
	private List<Object> proposedValues;
	private HashMap<Address, Help> readlist;
	private int[] accepted;
	private int[] decided;
	private Set<Address> topology;
	private Address self;


	public MultiPaxos(MultiPaxosInit event) {
		logger.info("Constructing MultiPaxos component.");
		self = event.getSelfAddress();
		topology = event.getAllAddresses();
		readlist = new HashMap<Address, Help>();
		accepted = new int[topology.size()];
		decided = new int[topology.size()];
		t=0;
		prepts =0;
		ats = 0;
		al = 0;
		pts = 0;
		pl = 0;

		subscribe(handleAscPropose, asc);
		subscribe(handleFplPrepare, fpl);
		subscribe(handleFplNack, fpl);
		

	}


	private Handler<AscPropose> handleAscPropose = new Handler<AscPropose>() {
		@Override
		public void handle(AscPropose event) {
			t++;
			Object v = event.getValue();
			if (pts == 0 ){
				pts  = (t*topology.size()) + self.getId();
				pv = av.subList(0, al); //is this correct?
				pl = 0;
				proposedValues.clear();
				proposedValues.add(v);
				readlist.clear();
				accepted = new int[topology.size()];
				decided = new int[topology.size()];
				for (Address q : topology){
					trigger(new FplSend(q, new Prepare(self, pts, al, t)), fpl);
				}
			} else if (readlist.size() <= topology.size()/2){
				proposedValues.add(v);
			} else if (!pv.contains(v)){
				pv.add(v);
				for (Address q : topology){
					if (readlist.containsKey(q)){
						trigger(new FplSend(q, new Accept(self,pts, v, pv.size()-1,t)), fpl);
					}
				}
			}
		}
	};
	
	private Handler<Prepare> handleFplPrepare = new Handler<Prepare>() {
		@Override
		public void handle(Prepare event) {
			t = Math.max(event.getT(), t)+1;
			int ts = event.getTs();
			Address q = event.getSource();
			if (ts < prepts){
				trigger(new FplSend(q, new Nack(self, ts, t)),fpl);
			} else {
				prepts = ts;
				trigger(new FplSend(q, new PrepareAck(self, ts, ats, av.subList(0, al), al, t)),fpl);
			}
		}
	};
	
	private Handler<Nack> handleFplNack = new Handler<Nack>() {
		@Override
		public void handle(Nack event) {
			
		}
	};
}
	
