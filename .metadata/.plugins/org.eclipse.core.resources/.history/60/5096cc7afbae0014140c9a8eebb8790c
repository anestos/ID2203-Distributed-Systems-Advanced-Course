package se.kth.ict.id2203.components.epfd;

import java.util.Set;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import se.kth.ict.id2203.components.flp2p.DelayDropLinkMessage;
import se.kth.ict.id2203.components.flp2p.DelayedMessage;
import se.kth.ict.id2203.ports.epfd.EventuallyPerfectFailureDetector;
import se.kth.ict.id2203.ports.flp2p.Flp2pDeliver;
import se.kth.ict.id2203.ports.flp2p.Flp2pSend;
import se.kth.ict.id2203.ports.pp2p.PerfectPointToPointLink;
import se.sics.kompics.ComponentDefinition;
import se.sics.kompics.Handler;
import se.sics.kompics.Negative;
import se.sics.kompics.Positive;
import se.sics.kompics.address.Address;
import se.sics.kompics.launch.NoLinkException;
import se.sics.kompics.timer.ScheduleTimeout;
import se.sics.kompics.timer.Timer;

public class Epfd extends ComponentDefinition {

	private static final Logger logger = LoggerFactory.getLogger(Epfd.class);
	private Positive<Timer> timer = requires(Timer.class);
	private Positive<PerfectPointToPointLink> pp2p = requires(PerfectPointToPointLink.class);
	private Negative<EventuallyPerfectFailureDetector> epfd = provides(EventuallyPerfectFailureDetector.class);
	
	public Epfd(EpfdInit init) {
	//	subscribe(handlePp2pSend, timer);
	//	subscribe(handleMessage, pp2p);
		subscribe(eventuallyPerfectFailureDetector, epfd);
	}
	
	private Handler<EventuallyPerfectFailureDetector> eventuallyPerfectFailureDetector = new Handler<EventuallyPerfectFailureDetector>() {
		@Override
		public void handle(EventuallyPerfectFailureDetector event) {
			Address destination = event.getDestination();

			if (destination.equals(self)) {
				// deliver locally
				Flp2pDeliver deliverEvent = event.getDeliverEvent();
				trigger(deliverEvent, flp2p);
				return;
			}

			double lossRate;
			long latency;
			try {
				lossRate = topology.getLossRate(self, destination);
				latency = topology.getLatencyMs(self, destination);
			} catch (NoLinkException e) {
				// there is no link to the destination, we drop the message
				return;
			}
			
			if (random.nextDouble() < lossRate) {
				// drop the message according to the loss rate
				return;
			}

			// make a DelayDropLinkMessage to be delivered at the destination
			DelayDropLinkMessage message = new DelayDropLinkMessage(self,
					destination, event.getDeliverEvent());

			if (latency > 0) {
				// delay the sending according to the latency
				ScheduleTimeout st = new ScheduleTimeout(latency);
				st.setTimeoutEvent(new DelayedMessage(st, message));
				trigger(st, timer);
			} else {
				// send immediately
				trigger(message, network);
			}
		}
	};

	private Handler<DelayedMessage> handleDelayedMessage = new Handler<DelayedMessage>() {
		@Override
		public void handle(DelayedMessage event) {
			trigger(event.getMessage(), network);
		}
	};

	private Handler<DelayDropLinkMessage> handleMessage = new Handler<DelayDropLinkMessage>() {
		@Override
		public void handle(DelayDropLinkMessage event) {
			trigger(event.getDeliverEvent(), flp2p);
		}
	};
}